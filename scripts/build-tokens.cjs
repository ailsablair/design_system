const fs = require('fs');
const path = require('path');

const brandName = process.argv[2] || 'echo';
const globalTokensPath = path.join(__dirname, '../design-tokens/global.json');
const brandTokensPath = path.join(__dirname, `../design-tokens/brands/${brandName}.json`);
const outputPath = path.join(__dirname, '../src/stories/foundations/tokens.css');

// Ensure directories exist
const outputDir = path.dirname(outputPath);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

function loadJSON(filePath) {
  if (!fs.existsSync(filePath)) {
    console.error(`Error: File not found at ${filePath}`);
    process.exit(1);
  }
  return JSON.parse(fs.readFileSync(filePath, 'utf8'));
}

const globalTokens = loadJSON(globalTokensPath);
const brandTokens = loadJSON(brandTokensPath);

// Merge tokens for resolution
// Brand tokens take precedence in the merge, but they are mostly in different namespaces
const allTokens = { ...globalTokens, ...brandTokens };

/**
 * Resolves a reference like "{path.to.token}" to its actual $value
 */
function getValueByPath(pathStr, tokens) {
  const parts = pathStr.replace(/[{}]/g, '').split('.');
  let current = tokens;
  for (const part of parts) {
    if (current && typeof current === 'object' && part in current) {
      current = current[part];
    } else {
      return null;
    }
  }
  return current && typeof current === 'object' && '$value' in current ? current.$value : current;
}

/**
 * Recursively resolves all references within the token object
 */
function resolveReferences(obj, tokens, depth = 0) {
  if (depth > 10) return obj; // Prevent infinite loops

  if (Array.isArray(obj)) {
    return obj.map(item => resolveReferences(item, tokens, depth + 1));
  }

  if (obj && typeof obj === 'object') {
    const newObj = {};
    for (const key in obj) {
      let value = obj[key];
      if (typeof value === 'string' && value.startsWith('{') && value.endsWith('}')) {
        const resolved = getValueByPath(value, tokens);
        newObj[key] = resolved !== null ? resolved : value;
      } else if (typeof value === 'object') {
        newObj[key] = resolveReferences(value, tokens, depth + 1);
      } else {
        newObj[key] = value;
      }
    }
    return newObj;
  }
  return obj;
}

/**
 * Converts camelCase or snake_case to kebab-case
 */
function toKebabCase(str) {
  return str
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .replace(/[\s_]+/g, '-')
    .toLowerCase();
}

/**
 * Transforms a DTCG shadow array into a standard CSS box-shadow string
 */
function transformShadow(shadowValue) {
  if (typeof shadowValue === 'string') return shadowValue;
  if (!Array.isArray(shadowValue)) return 'none';

  return shadowValue
    .map(s => {
      if (s.backgroundBlur) return ''; // Handled separately if needed
      const inset = s.type === 'innerShadow' ? 'inset ' : '';
      return `${inset}${s.offsetX} ${s.offsetY} ${s.blur} ${s.spread || '0px'} ${s.color}`;
    })
    .filter(Boolean)
    .join(', ') || 'none';
}

/**
 * Flattens the token object into CSS variables
 */
function flattenTokens(obj, prefix = '') {
  let vars = [];
  for (const key in obj) {
    const value = obj[key];
    const currentPrefix = prefix ? `${prefix}-${toKebabCase(key)}` : toKebabCase(key);

    if (value && typeof value === 'object' && '$value' in value) {
      const type = value.$type;
      const val = value.$value;

      if (type === 'typography') {
        // Flatten typography objects into individual properties
        for (const prop in val) {
          vars.push(`  --${currentPrefix}-${toKebabCase(prop)}: ${val[prop]};`);
        }
      } else if (type === 'shadow') {
        vars.push(`  --${currentPrefix}: ${transformShadow(val)};`);
      } else {
        // Standard token
        vars.push(`  --${currentPrefix}: ${val};`);
      }
    } else if (value && typeof value === 'object' && !Array.isArray(value)) {
      // It's a category, recurse
      vars.push(...flattenTokens(value, currentPrefix));
    }
  }
  return vars;
}

const resolvedTokens = resolveReferences(allTokens, allTokens);
const cssVars = flattenTokens(resolvedTokens);

// Add custom aliases for backward compatibility and convenience
const customAliases = [
  '  /* --- Custom Brand Aliases --- */',
  `  --brand-name: "${resolvedTokens.brand?.name || brandName}";`,
  '  --typeface-heading: var(--brand-typeface-heading), sans-serif;',
  '  --typeface-body: var(--brand-typeface-body), sans-serif;',
  '',
  '  /* --- Backward Compatibility Mappings --- */',
  '  --primary-blue-blue: var(--primary-blue-main, var(--brand-primary-blue-main));',
  '  --type-typeface-archivo: var(--brand-typeface-heading), sans-serif;',
  '  --type-typeface-roboto-flex: var(--brand-typeface-body), sans-serif;'
];

const cssContent = `/**
 * DO NOT EDIT THIS FILE DIRECTLY.
 * This file is auto-generated from JSON design tokens using build-tokens.cjs
 * Brand: ${brandName.toUpperCase()}
 */

:root {
${cssVars.join('\n')}

${customAliases.join('\n')}
}
`;

fs.writeFileSync(outputPath, cssContent);
console.log(`Successfully generated production tokens for brand: ${brandName.toUpperCase()}`);
